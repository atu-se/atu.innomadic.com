---
title: Formal Languages and Automata Theory
subtitle: 5. Context-Free Languages
date: February 24, 2019
export_on_save:
  pandoc: true
output:
  custom_document:
    path: lecture5-slides.html
    pandoc_args: ["-t", "revealjs", "-V",  "revealjs-url=../../../presentation/reveal.js", "-V", "theme=beige", "--slide-level=2", "--standalone", "--katex=../../../presentation/katex/"]
---

# Introduction

## Context-Free Grammars

* In this chapter we present context-free grammars (CFGs), a more powerful method of describing languages.
* Such grammars can describe certain features that have a recursive structure, which makes them useful in a variety of applications.

## Context-Free Grammars

* Context-free grammars were first used in the study of human languages.
* One way of understanding the relationship of terms such as noun, verb, and preposition and their respective phrases leads to a natural recursion because noun phrases may appear inside verb phrases and vice versa.
* Context-free grammars help us organize and understand these relationships.

## Application: Compilers

* An important application of context-free grammars occurs in the specification and compilation of programming languages.
* A grammar for a programming language often appears as a reference for people trying to learn the language syntax.
* Most compilers and interpreters contain a component called a parser that extracts the meaning of a program prior to generating the compiled code or performing the interpreted execution.

# Context-Free Grammars

## Context-Free Grammars

* The following is an example of a context-free grammar, which we call G~1~.

$$
A \longrightarrow 0A1 \\
A\longrightarrow B \\
B\longrightarrow \#
$$

## CFG Components

* collection of **substitution rules**, also called productions.
* Each rule appears as a line in the grammar, comprising a symbol and a string separated by an arrow.
* The symbol is called a **variable**.
* The string consists of variables and other symbols called **terminals**.

## Context-Free Grammars

* The variable symbols often are represented by capital letters.
* The terminals are analogous to the input alphabet and often are represented by lowercase letters, numbers, or special symbols.
* One variable is designated as the **start variable**.
* It usually occurs on the left-hand side of the topmost rule.

## Example CFG G1

$$
A \longrightarrow 0A1 \\
A\longrightarrow B \\
B\longrightarrow \#
$$

* For example, grammar G~1~ contains three rules.
* G~1~’s variables are A and B, where A is the start variable.
* Its terminals are 0, 1, and #.

## Generating Strings

1. Write down the start variable. It is the variable on the left-hand side of the top rule, unless specified otherwise.
2. Find a variable that is written down and a rule that starts with that variable. Replace the written down variable with the right-hand side of that rule.
3. Repeat step 2 until no variables remain.

## Generating Strings

G1:
$$
A \longrightarrow 0A1 \\
A\longrightarrow B \\
B\longrightarrow \#
$$

* G~1~ generates 000#111.  
* The sequence of substitutions to obtain a string is called its **derivation**.  

## Derivation from G1

$$
A \longrightarrow 0A1 \\
A\longrightarrow B \\
B\longrightarrow \#
$$

* A derivation of string 000#111 in grammar G~1~ is:
$$ A \Rightarrow 0A1 \Rightarrow 00A11 \Rightarrow 000A111 \Rightarrow 000B111 \Rightarrow 000\#111 $$

## Parse Tree

A derivation may be pictures pictorially using a **parse tree**.

## Parse Tree

![Parse Tree of G1](lecture5-diagram1.png){.stretch}

## Context-Free Languages

* All strings generated in this way constitute the language of the grammar.
* We write $L(G_{1})$ for the language of Grammar $G_{1}$.
* $L(G(_{1}))$ is $\{0^n\#1^n | n \geq 0\}$
* **Any language that can be generated by some context-free grammar is called a context-free language (CFL)**

## CFG Example G2

$${\scriptsize\begin{aligned}⟨SENTENCE⟩ &\longrightarrow ⟨NOUN-PHRASE⟩⟨VERB-PHRASE⟩
\\ ⟨NOUN-PHRASE⟩ &\longrightarrow ⟨CMPLX-NOUN⟩ | ⟨CMPLX-NOUN⟩⟨PREP-PHRASE⟩
\\ ⟨VERB-PHRASE⟩ &\longrightarrow ⟨CMPLX-VERB⟩ | ⟨CMPLX-VERB⟩⟨PREP-PHRASE⟩
\\ ⟨PREP-PHRASE⟩ &\longrightarrow ⟨PREP⟩⟨CMPLX-NOUN⟩
\\ ⟨CMPLX-NOUN⟩ &\longrightarrow ⟨ARTICLE⟩⟨NOUN⟩
\\ ⟨CMPLX-VERB⟩ &\longrightarrow ⟨VERB⟩ | ⟨VERB⟩⟨NOUN-PHRASE⟩
\\ ⟨ARTICLE⟩ &\longrightarrow a | the
\\ ⟨NOUN⟩ &\longrightarrow boy | girl | flower
\\ ⟨VERB⟩ &\longrightarrow touches | likes | sees
\\ ⟨PREP⟩ &\longrightarrow with
\end{aligned} } $$

## CFG Example G2

Grammar G~2~ has:

* 10 variables (the capitalized grammatical terms written inside brackets)
* 27 terminals (the standard English alphabet plus a space character)
* 18 rules.

## CFG Example G2

Strings in L(G~2~) include:

* a boy sees
* the boy sees a flower
* a girl with a flower likes the boy

## CFG Example G2

The following is a derivation of `a boy sees`:

$$\begin{aligned}⟨SENTENCE⟩ &\Rightarrow ⟨NOUN-PHRASE⟩⟨VERB-PHRASE⟩ \\ &\Rightarrow ⟨CMPLX-NOUN⟩⟨VERB-PHRASE⟩
\\ &\Rightarrow ⟨ARTICLE⟩⟨NOUN⟩⟨VERB-PHRASE⟩ \\ &\Rightarrow a ⟨NOUN⟩⟨VERB-PHRASE⟩
\\ &\Rightarrow a\, boy ⟨VERB-PHRASE⟩
\\ &\Rightarrow a\, boy ⟨CMPLX-VERB⟩
\\ &\Rightarrow a\, boy ⟨VERB⟩ \\ &\Rightarrow a\, boy\ sees \end{aligned}$$

# Formal Definition

## Formal Definition of a CFG

A context-free grammar is a 4-tuple (V, Σ, R, S), where:

1. V is a finite set called the variables,
2. Σ is a finite set, disjoint from V , called the terminals,
3. R is a finite set of rules, with each rule being a variable and a
string of variables and terminals, and
4. S ∈ V is the start variable.

## Terminology

* If u, v, and w are strings of variables and terminals, and A → w is a rule of the grammar, we say that uAv **yields** uwv, written uAv ⇒ uwv.
* Say that u **derives** v, written u $\xRightarrow{*}$ v, if $u = v$ or if a sequence $u_{1},u_{2},...,u_{k}$ exists for k ≥ 0 and

$$ u \Rightarrow u_{1} \Rightarrow u_{2} \Rightarrow ...\Rightarrow u_{k}\Rightarrow v.$$

* The language of the grammar is:

$$\{w \isin \Sigma ^∗\ |\ S \xRightarrow{*} w\}.$$

## Example G4

Consider grammar G~4~ =(V,Σ,R,⟨EXPR⟩).

* V is {⟨EXPR⟩,⟨TERM⟩,⟨FACTOR⟩}
* Σ is {a,+, x,(,)}
* The rules are:

$$\begin{aligned}⟨EXPR⟩ &\Rightarrow ⟨EXPR⟩+⟨TERM⟩ | ⟨TERM⟩ \\
⟨TERM⟩ &\Rightarrow ⟨TERM⟩\times⟨FACTOR⟩ | ⟨FACTOR⟩ \\
  ⟨FACTOR⟩ &\Rightarrow(⟨EXPR⟩)|a \end{aligned}$$

## Example G4

  $$\begin{aligned}⟨EXPR⟩ &\Rightarrow ⟨EXPR⟩+⟨TERM⟩ | ⟨TERM⟩ \\
  ⟨TERM⟩ &\Rightarrow ⟨TERM⟩\times⟨FACTOR⟩ | ⟨FACTOR⟩ \\
    ⟨FACTOR⟩ &\Rightarrow(⟨EXPR⟩)|a \end{aligned}$$

Draw parse trees for $a+a\times a$ and $(a+a)\times a$.

## Example G4

Draw parse trees for $a+a\times a$ and $(a+a)\times a$.

![G4 Parse Trees](lecture5-diagram2.png)

## Compiler Application

* A compiler translates code written in a programming language into another form, usually one more suitable for execution.
* To do so, the compiler extracts the meaning of the code to be compiled in a process called parsing.
* One representation of this meaning is the parse tree for the code, in the context-free grammar for the programming language

# Designing Context-Free Grammars

## Designing CFGs

* As with the design of finite automata, the design of context-free grammars requires creativity.
* Context-free grammars are even trickier to construct than finite automata because we are more accustomed to programming a machine for specific tasks than we are to describing languages with grammars.

## CFG Design Technique 1

* Many CFLs are the union of simpler CFLs. If you must construct a CFG for a CFL that you can break into simpler pieces, do so and then construct individual grammars for each piece.
* These individual grammars can be easily merged into a grammar for the original language by combining their rules
* Then add the new rule $S → S_{1} | S_{2} | ··· | S_{k},$ where the variables Si are the start variables for the individual grammars

## CFG Design Technique 2

* Constructing a CFG for a language that happens to be regular is easy if you can first construct a DFA for that language.
* You can convert any DFA into an equivalent CFG as follows.

## CFG Design Technique 2

1. Make a variable Ri for each state qi of the DFA.
2. Add the rule Ri → aRj to the CFG if δ(qi,a) = qj is a transition in the DFA.
3. Add the rule Ri → ε if qi is an accept state of the DFA.
4. Make R0 the start variable of the grammar, where q0 is the start state of the machine.
5. Verify on your own that the resulting CFG generates the same language that the DFA recognizes.

## CFG Design Technique 3

* CFLs contain strings with two substrings that are “linked” in the sense that a machine for such a language would need to remember an unbounded amount of information about one of the substrings to verify that it corresponds properly to the other substring
* This situation occurs in the language {0^n1^n| n ≥ 0} because a machine would need to remember the number of 0s in order to verify that it equals the number of 1s.
* You can construct a CFG to handle this situation by using a rule of the form R → uRv, which generates strings wherein the portion containing the u’s corresponds to the portion containing the v’s.

## CFG Design Technique 4

In more complex languages, the strings may contain certain structures that appear recursively as part of other (or the same) structures. That situation occurs in the grammar that generates arithmetic expressions in Example 2.4. Any time the symbol a appears, an entire parenthesized expression might appear recursively instead. To achieve this effect, place the variable symbol generating the structure in the location of the rules corresponding to where that structure may recursively appear.


## Ambiguity

* Sometimes a grammar can generate the same string in several different ways.
* Such a string will have several different parse trees and thus several different meanings.
* This result may be undesirable for certain applications, such as programming languages, where a program should have a unique interpretation.
* If a grammar generates the same string in several different ways, we say that the string is derived ambiguously in that grammar.
* If a grammar generates some string ambiguously, we say that the grammar is ambiguous.











## Ambiguity

1. Consider grammar $G_{3} = ({S}, {a,b}, R, S)$. The set of rules, _R_, is:



$$S →aSb|SS|ε.$$

a. Give two examples of strings in $L(G_{3})$.
b. Write a leftmost derivation of $G_{3}$.
c. Write a rightmost derivation of $G_{3}.
